scp out/arduino/FATFS_sdcard_test.hex dhruv@algwsn.ibr.cs.tu-bs.de:
By default MBR sector is 1st sector.
Drives without MBR 1st 3 bytes are EBh 3Ch 90h (FAT16) and EBh 58h and 90h (FAT32).

Assume little endian (Intel all microprocessors). Boot Signature in MBR is AA55h
510 - 55h, 511 - AAh

in MBR:
0-445 -> Executable code
446-509 -> Partition Table
510-511 -> Boot Signature

Debugging wf_open(*path) {
dj.fn = sfn;
	follow_path() {
	dj->sclust = 0;
	for(;;)
		create_name(dj, &path) {
		sfn = dj->fn;
		dj->fn has name in "FOOBAR01TXT" format
		path has dummy text~~~~
		}
		
		dir_find(dj, dir) {
			dir_rewind(dj) {
			dj->index = 0;
			clst = dj->sclust; (0)
			if(FAT32 and !clst)
				clst = (CLUST)fs->dirbase; (3798)
			dj->clust = clst; (3798)
			dj->sect = clst ? clust2sect(clst) : fs->dirbase; (####)
			}
		}
	}
}

Debugging f_open() {
	...
	follow_path()
	dir_register(&dj) {
		dir_alloc(dp, 1) {
			dir_sdi(dp, 0);
			loop {
				move_window(dp->fs, dp->sect) {
					sync_window(fs)		// Writes dirty block to disk
					...					// read data from dp->sect into buffer
				}
				...		// Find empty or deleted dir entry
			}
		}
		...				// move window to dp->sect
		...				// clear and copy dp->fn to dir[32]	
	}
	
}

*****sync_window flushes buffer, its called by move_window, dir_next, mk_dir.

fptr points to exact Byte offset in file where to start writing. It will over-write without warning. To append, use lseek(filesize()) to move pointer to end of file. In case of blank file, use create_chain(0) to allocate first cluster. To extend length of file and allocate new clusters, use create_chain(clst).

lseek() sets curr_clst, org_clst, dsect for non-empty files.

My write ----->>>>>
Possible cases:
a) fptr points to start/mid cluster, cluster has empty space.
start writing straightaway
b) fptr points to end of cluster
c) fptr points to 0 (new file)
allocate new cluster and start writing

determine if new cluster needed?
-> 	if(512 - (fptr % 512) >= btw) then no need of cluster
	else

#C8C8C8
#A0A0A0
#BEBEE6

Yep, the idea in the wiselib is that basically everything is a
templated class (and thus should be defined completely in one header
file, also you can write method in inline-syntax the compiler will
figure out whether to really inline them or not).

Usually the first template parameter of virtually everything in the
wiselib is the osmodel, which you most often use to derive the basic
types Os::size_t and Os::block_data_t.

For a filesystem of course one template parameter should refer to the
block device in use, so you would come out at something like

template<
  typename OsModel_P,
  typename BlockMemory_P = typename OsModel_P::BlockMemory, // default to Os' default block memory if not specified
  int SOME_USER_DEFINED_CONSTANT_P = 1234,
  // etc...
>
class Fat32 {
  public:
    typedef BlockMemory_P BlockMemory;
    int init(BlockMemory& block_memory, etc...) {
      // initialize
    }

    // your methods here
};


So usage would be like this:

typedef Fat32<Os, SomeBlockMemory, etc...> MyFS;

// different block memories might have different initialization procedures,
// you dont need to care about that, just expect that you get a properly initialized BM
SomeBlockMemory block_memory;
block_memory.init();

MyFS fs;
fs.init(block_memory, etc..);
fs.open("foo.txt"); // or whatever interface you come up with


This way a user could e.g. intantiate 10 different block memories (different SD card partitions, RAM-block-memories, etc...)
and run different file systems on each.


--------------------------------------------------------------------------------------------------------------------------
I get this warning, and then an error when using Ram block memory, (works fine for file block memory)

On make:
/usr/include/x86_64-linux-gnu/bits/string3.h:51:71: warning: call to void* __builtin___memcpy_chk(void*, const void*, long unsigned int, long unsigned int) will always overflow destination buffer [enabled by default]
   return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));

and on running I get:
*** buffer overflow detected ***: ./out/pc/FATFS_sdcard_test terminated
======= Backtrace: =========
/lib/x86_64-linux-gnu/libc.so.6(+0x741cf)[0x7f914cc591cf]
/lib/x86_64-linux-gnu/libc.so.6(__fortify_fail+0x5c)[0x7f914ccf0b2c]
/lib/x86_64-linux-gnu/libc.so.6(+0x10a9f0)[0x7f914ccef9f0]
./out/pc/FATFS_sdcard_test[0x400ade]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf5)[0x7f914cc06ec5]
./out/pc/FATFS_sdcard_test[0x400bbf]
======= Memory map: ========
00400000-00402000 r-xp 00000000 08:01 58729                              /home/wiselib/wiselib/apps/generic_apps/FATFS_sdcard_test/out/pc/FATFS_sdcard_test
00601000-00602000 r--p 00001000 08:01 58729                              /home/wiselib/wiselib/apps/generic_apps/FATFS_sdcard_test/out/pc/FATFS_sdcard_test
00602000-00603000 rw-p 00002000 08:01 58729                              /home/wiselib/wiselib/apps/generic_apps/FATFS_sdcard_test/out/pc/FATFS_sdcard_test
00603000-06a03000 rw-p 00000000 00:00 0 
07941000-07962000 rw-p 00000000 00:00 0                                  [heap]
7f914c6c9000-7f914c6df000 r-xp 00000000 08:01 137952                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7f914c6df000-7f914c8de000 ---p 00016000 08:01 137952                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7f914c8de000-7f914c8df000 rw-p 00015000 08:01 137952                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7f914c8df000-7f914c9e4000 r-xp 00000000 08:01 137975                     /lib/x86_64-linux-gnu/libm-2.19.so
7f914c9e4000-7f914cbe3000 ---p 00105000 08:01 137975                     /lib/x86_64-linux-gnu/libm-2.19.so
7f914cbe3000-7f914cbe4000 r--p 00104000 08:01 137975                     /lib/x86_64-linux-gnu/libm-2.19.so
7f914cbe4000-7f914cbe5000 rw-p 00105000 08:01 137975                     /lib/x86_64-linux-gnu/libm-2.19.so
7f914cbe5000-7f914cda1000 r-xp 00000000 08:01 137925                     /lib/x86_64-linux-gnu/libc-2.19.so
7f914cda1000-7f914cfa0000 ---p 001bc000 08:01 137925                     /lib/x86_64-linux-gnu/libc-2.19.so
7f914cfa0000-7f914cfa4000 r--p 001bb000 08:01 137925                     /lib/x86_64-linux-gnu/libc-2.19.so
7f914cfa4000-7f914cfa6000 rw-p 001bf000 08:01 137925                     /lib/x86_64-linux-gnu/libc-2.19.so
7f914cfa6000-7f914cfab000 rw-p 00000000 00:00 0 
7f914cfab000-7f914d091000 r-xp 00000000 08:01 272887                     /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.19
7f914d091000-7f914d290000 ---p 000e6000 08:01 272887                     /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.19
7f914d290000-7f914d298000 r--p 000e5000 08:01 272887                     /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.19
7f914d298000-7f914d29a000 rw-p 000ed000 08:01 272887                     /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.19
7f914d29a000-7f914d2af000 rw-p 00000000 00:00 0 
7f914d2af000-7f914d2c8000 r-xp 00000000 08:01 138045                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f914d2c8000-7f914d4c7000 ---p 00019000 08:01 138045                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f914d4c7000-7f914d4c8000 r--p 00018000 08:01 138045                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f914d4c8000-7f914d4c9000 rw-p 00019000 08:01 138045                     /lib/x86_64-linux-gnu/libpthread-2.19.so
7f914d4c9000-7f914d4cd000 rw-p 00000000 00:00 0 
7f914d4cd000-7f914d4f0000 r-xp 00000000 08:01 137901                     /lib/x86_64-linux-gnu/ld-2.19.so
7f914d6d0000-7f914d6d6000 rw-p 00000000 00:00 0 
7f914d6eb000-7f914d6ef000 rw-p 00000000 00:00 0 
7f914d6ef000-7f914d6f0000 r--p 00022000 08:01 137901                     /lib/x86_64-linux-gnu/ld-2.19.so
7f914d6f0000-7f914d6f1000 rw-p 00023000 08:01 137901                     /lib/x86_64-linux-gnu/ld-2.19.so
7f914d6f1000-7f914d6f2000 rw-p 00000000 00:00 0 
7fff63b13000-7fff63b34000 rw-p 00000000 00:00 0                          [stack]
7fff63b46000-7fff63b48000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
Aborted (core dumped)
